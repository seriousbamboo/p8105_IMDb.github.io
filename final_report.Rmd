---
title: "Final report"
author: "Jiying Han, Liucheng Shi, Wenhao Gou, Yatong Feng, Zhe Chen"
output: 
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=FALSE, warning=FALSE, include=FALSE}
library(tidyverse)
library(stringr)
library(reshape2)
library(arsenal)
library(plotly)
library(lubridate)
library(viridis)
library(ggridges)
library(hrbrthemes)
library(viridis)
```

```{r, warning=FALSE, echo = FALSE, message=FALSE}
#Import cleaned data
imdb_model = 
  read_csv("./data/imdb_model.csv")

imdb_model = 
  imdb_model %>%
  mutate(
    num_genres = rowSums(imdb_model[,13:36]),
    mult_genre = ifelse(num_genres >1, 1, 0)
  )

imdb_model_genre = 
  imdb_model %>% 
  select(gross, Action: Film.Noir)

imdb_model_no_genre = 
  imdb_model %>% 
  select(-(Action: Film.Noir))
```

<img src = "images/theaters.png" style = "width:100%"> 

###### Image: REUTERS/Mario Anzuon

## Motivation:

Given the scenario of social distancing and temporary closure of movie theaters across the United States, the pandemic did hit the movie industry severly not only for a domestic market but also in a global scale. According to Comoscore, it has been a dramatic 76% drop in domestic box office in 2020 compared with the same point in 2019. Substantial resturcting in the movie industry urge the producers and directors to be effective and efficient as much as possible. Box-office prediction has never been such a crucial problem in the film industry, such that profitability is directly associated with strategy made by investors and producers. 

Our main goal is to:

*   use skinny to explore the association between the box-office gross and  other variables including genres, budget, and IMDb score
*   create word cloud, radar map on contributing factors
*   generate linear regression model to predict box-office revenue 


## Related Work:

#### **Related Work**

The following resources are a sample of what inspired this project.

1. "Here's how badly coronavirus has decimated the box office" *CNN*, October 14, 2020. [Link.](https://edition.cnn.com/2020/10/14/media/box-office-coronavirus/index.html)
2. "Disney-owned theaters? Masks with your ticket? Moviegoing could look quite different post-pandemic" *USA TODAY*, January 16, 2020. [Link.](https://www.usatoday.com/story/entertainment/movies/2020/06/14/future-moviegoing-could-coronavirus-kill-movie-theaters/3186292001/)
3. "Can there be a fairy-tale ending for Hollywood after COVID-19?" *WORLD ECONOMIC FORUM*, January 23, 2020. [Link.](https://www.weforum.org/agenda/2020/07/impact-coronavirus-covid-19-hollywood-global-film-industry-movie-theatres/)


## Intial Questions:

- What is the general trend of gross across time? Will this pattern vary for different genres?
- What is the association between Gross and other variables including IMDB_score, facebook_likes?
- Is director a significant predictor of Gross?
- the crude relationship between number of reviews and Gross


## Data

### *Data Sources*

* Primary data source: [Kaggle](https://www.kaggle.com/carolzhangdc/imdb-5000-movie-dataset) 
* release ymd(year, month, date): [IMDb] (https://https://www.imdb.com/)

&nbsp;

### *Variables of interest*

##### **Outcomes**

- `gross`: total gross for the movies

##### **Candidate Predictors**

Variable name             | Data type | Variable explanation
--------------------------|-----------|---------------
`director_name`           |chr        |Name of the Director of the movie
`director_facebook_likes` |dbl        |Number of likes of the director on his/her Facebook Page
`actor_1_name`            |chr        |Primary actor starring in the movie
`actor_1_facebook_likes`  |dbl        |Number of likes of the Actor_1 on his/her Facebook Page
`cast_total_facebook_likes`|dbl       |Number of likes of the total casts on his/her Facebook Page
`movie_facebook_likes`    |dbl        |Number of likes of the movie on its Facebook Page
`duration`                |dbl        |Length for the movie
`genres`                  |chr|Total genres for the movie
`movie_title`             |chr|The title for the movie
`num_critic_for_reviews`  |dbl        |Number of the critic reviews for the movie
`num_voted_users`         |dbl        |Number of users who review for the movie
`num_user_for_reviews`    |dbl        |Number of users reviews for the movie
`language`|chr|Main language for the movie
`country`|chr|Country for the movie
`budget`|dbl|Total budget for the movie
`title_year`|dbl|Release year for the movie
`imdb_score`|dbl|Overall score for the movie on IMDB
`aspect_ratio`|dbl|Aspect ratio for the movie


&nbsp;

### *Data Cleaning*

- For model
  - Keep only interested variables
  - Manipulate `genres` and `plot_keywords` column:
  - Input example: "avatar|future|marine|native|paraplegic"
  - Purpose: separate into multiple columns with 0 and 1
    - Find all the genres: `unique`, `unlist`, and `str_split`
    - Create a blank dataframe with all 0s
      - Columns number is equal to raw dataset
      - Row number is equal to genres types
    - Use for loop: test for all the movies, if it has the certain genres, change the corresponding number from 0 to 1
      
```{r, eval = F}
imdb_raw = read_csv("./data/movie_metadata.csv")
#data cleaning 
imdb = imdb_raw %>%
  as.data.frame() %>% 
  drop_na(movie_title) %>%
#keep only interested variables 
  select(
    -color, -actor_2_name, -actor_2_facebook_likes, -actor_3_name, -actor_3_facebook_likes, -facenumber_in_poster, -movie_imdb_link, -content_rating, -plot_keywords
  ) %>%
  drop_na(gross)

rownames(imdb) = c(1:dim(imdb)[1])

#separate genres into multiple columns
a = imdb$genres
genres_list = unique(unlist(str_split(a, "[|]")))

niubility = as.data.frame(matrix(0, nrow=dim(imdb)[1], ncol=length(genres_list)))
colnames(niubility) = genres_list

for (i in 1:dim(imdb)[1]){
  b = unlist(str_split(imdb$genres[i], "[|]"))
  for (word in b){
    niubility[i, word] = 1
    }
  }

rownames(niubility) = c(1:dim(imdb)[1])

imdb_after_genre = data.frame(imdb, niubility)

imdb_model = 
  imdb_after_genre %>% 
  select(num_critic_for_reviews:gross, num_voted_users:num_user_for_reviews, budget, imdb_score: Film.Noir)

imdb_model_clean = 
  imdb_model %>% 
  select(num_critic_for_reviews:num_user_for_reviews, imdb_score, Action:Fantasy, Romance:Family, Drama, Sport:Horror, Music)
```


- For shiny: `separate` + `pivot_longer`:
    - Purpose: all the original words as the filter for nearly all the plots
      - Use `separate` function to split the column into multiply sub-columns (g1-g8). 8 is the maximum genre type of a single film. By then, unused columns of a single film will be recorded as NA
      - Use `pivot_longer` to convert these sub-columns to the pattern as id – value. Then, we can clean the value column (drop NA) and ignore the id value. 
      - `plot_keywords` columns is treated same as this
      
- Initial cleaning for shiny  
  - manipulate the genre and plot_keywords columns  
  - separate and pivot_large those two columns

```{r, eval = F}
### Import data

imdb_raw = read_csv("./Dataset/movie_metadata.csv")



### Get the year month date:

get_ymd <- function(url_raw)
{
  url = str_replace(url_raw,"\\?ref","releaseinfo?ref")
  swm_html = read_html(url)
  ymd = 
    swm_html %>% 
    html_nodes(css = ".release-date-item:nth-child(1) .release-date-item__date") %>% 
    html_text()
  return(ymd)
}

#imdb = 
#  imdb_raw %>% 
#  mutate(ymd = map(movie_imdb_link, get_ymd)) %>% 
#  unnest(ymd)

### Cleaning
imdb_clean = 
  imdb_raw %>%
  drop_na(movie_title, gross) %>% 
  mutate(movie_title = str_replace(movie_title,"\\?$","")) %>% 
  separate(genres,
           sep = "\\|",
           into = c("g1","g2","g3","g4","g5","g6","g7","g8")) %>% 
  pivot_longer(g1:g8,
               names_to = "dummy",
               values_to = "genres") %>%
  select(-dummy) %>% 
  drop_na(genres) %>% 
  separate(plot_keywords, 
           sep = "\\|",
           into = c("g1","g2","g3","g4","g5","g6","g7","g8")) %>% 
  pivot_longer(g1:g8,
               names_to = "dummy",
               values_to = "plot_keyword") %>%
  select(-dummy) %>% 
  drop_na(plot_keyword)

  
write.csv(imdb_clean,"./Dataset/imdb_explore_clean.csv", fileEncoding = "utf-8")
```

      
- Reading ymd from IMDb:
  - Use css selector to identify the target element
  - For loop and get ymd information over repeated writing 
              
```{r, eval = F}
# ymd

### Get the year month date:

get_ymd <- function(url_raw)
{
  url = str_replace(url_raw,"\\?ref","releaseinfo?ref")
  swm_html = read_html(url)
  ymd = 
    swm_html %>% 
    html_nodes(css = ".release-date-item:nth-child(1) .release-date-item__date") %>% 
    html_text()
  return(ymd)
}

for (i in 1:nrow(dataset_r)) {
  test_df = read_csv("./data/imdb_release.csv")
  if (is.na(test_df[[3]][i])) {
    test_df[[3]][i] <- get_ymd(test_df[[2]][i])
  } 
  test_df %>% 
    write_csv(.,"./data/imdb_release.csv")
}

imdb_ymd = read_csv("./data/imdb_release.csv") %>% 
  separate(release_date, into = c("day","month","year"), sep = " ", fill = "left") %>% 
  write_csv(.,"./data/imdb_ymd.csv")
```

- Animation plot
  - Use `left_join` to intergate ymd with our dataset     

```{r animation, eval = F}
# Animation 
imdb_clean = read_csv("./dataset/movie_metadata.csv") %>% 
  drop_na(movie_title, gross) %>% 
  mutate(movie_title = str_replace(movie_title,"\\?$","")) %>% 
  separate(genres,
           sep = "\\|",
           into = c("g1","g2","g3","g4","g5","g6","g7","g8")) %>% 
  pivot_longer(g1:g8,
               names_to = "dummy",
               values_to = "genres") %>%
  select(-dummy) %>% 
  drop_na(genres)

imdb_ymd = read_csv("./dataset/imdb_ymd.csv") %>% 
  select(-movie_imdb_link)

month_df = 
  tibble(
    month_value = 1:12,
    month = month.name
  )

imdb_m = left_join(imdb_ymd, month_df, by = "month") %>% 
  select(-month) %>% 
  mutate(month = month_value, .keep = "unused")

imdb_cleanymd = left_join(imdb_clean,imdb_m,by = "movie_title")
imdb_cleanymd %>% 
  select(gross, genres, month, year, imdb_score) %>% 
  write_csv("./data/shiny_animation.csv")
```
- Circulation plot
  - Use `unqiue`, `distinct` and `sort` to order the movie_list     
```{r, eval = F}
#Circulation plot

imdb_cir <- read_csv("./Dataset/imdb_explore_clean.csv")

imdb_cir <-
  imdb_cir %>% 
  select(movie_title, director_name, title_year, gross, genres) %>% 
  distinct(movie_title, genres,  .keep_all = T)

valuelist <- unique(pull(imdb_cir, gross))

valuelist <- sort(valuelist, decreasing = T)[1:50]

imdb_cir_final <-
  imdb_cir %>% 
  filter(gross %in% valuelist) %>% 
  arrange(gross)

write_csv(imdb_cir_final, "./Dataset/shiny_circulation.csv")

```
- Gross vs. everything plot
  - Select the interested numeric variables, title and genre
  - Distinct by title and genre     
```{r, eval = F}
# Plotly

df1 = read_csv("./Dataset/imdb_explore_clean.csv") %>% 
  select(movie_title,genres, gross, num_critic_for_reviews,duration,director_facebook_likes,
         actor_3_facebook_likes,actor_2_facebook_likes,actor_1_facebook_likes,
         num_voted_users, facenumber_in_poster, num_user_for_reviews,
         budget, imdb_score, aspect_ratio, movie_facebook_likes, title_year) %>% 
  mutate(title_year = as.numeric(title_year)) %>% 
  distinct(movie_title, genres, .keep_all = T)
  

write_csv(df1, "./Dataset/shiny_plotly.csv")
```
- Radar plot
  - write function to repeat the summarize process by genres     
```{r, eval = F}
## Radar plot

### Step 1. Extract relevant data:

imdb_vis <- read_csv("./Dataset/imdb_explore_clean.csv")

imdb_radar <-
  imdb_vis %>% 
  select(movie_title,genres, gross, num_critic_for_reviews,duration,director_facebook_likes,
         actor_3_facebook_likes,actor_2_facebook_likes,actor_1_facebook_likes,
         num_voted_users, facenumber_in_poster, num_user_for_reviews,
         budget, imdb_score, aspect_ratio, movie_facebook_likes) %>% 
  distinct(movie_title,genres,.keep_all = TRUE) 

imdb_radar_raw = imdb_radar

name_list_radar = names(imdb_radar)


### Step 2. Functions for summarize:

group_and_standardize <- function(Tibble)
{
  name_list_radar = names(Tibble)
  Tibble_begin <- 
    Tibble %>% 
    select(name_list_radar[2]) %>% 
    group_by(genres) %>% 
    summarise(n=n())
  
  for (i in 3:length(name_list_radar))
  {
    Tibble_process <- 
      Tibble %>% 
      select(name_list_radar[2],name_list_radar[i]) %>% 
      rename(dummyname = name_list_radar[i]) %>% 
      group_by(genres) %>% 
      summarise(dummy = mean(dummyname, na.rm = T)) %>% 
      mutate(dummy = (dummy - min(dummy, na.rm = T))/(max(dummy, na.rm = T)- min(dummy, na.rm = T))) %>% 
      select(dummy)
    Tibble_begin = cbind(Tibble_begin,Tibble_process)
  }
  return(Tibble_begin)
}


group_without_standardize <- function(Tibble)
{
  name_list_radar = names(Tibble)
  Tibble_begin <- 
    Tibble %>% 
    select(name_list_radar[2]) %>% 
    group_by(genres) %>% 
    summarise(n=n())
  
  for (i in 3:length(name_list_radar))
  {
    Tibble_process <- 
      Tibble %>% 
      select(name_list_radar[2],name_list_radar[i]) %>% 
      rename(dummyname = name_list_radar[i]) %>% 
      group_by(genres) %>% 
      summarise(dummy = mean(dummyname, na.rm = T)) %>% 
      select(dummy)
    Tibble_begin = cbind(Tibble_begin,Tibble_process)
  }
  return(Tibble_begin)
}


## The final data

imdb_radar <- group_and_standardize(imdb_radar)
names(imdb_radar) = c("genres","N", name_list_radar[3:length(name_list_radar)])
imdb_radar <-
  imdb_radar %>% 
  as_tibble() %>% 
  #select(N) %>% 
  mutate(N = (N - min(N))/(max(N)-min(N))) %>% 
  pivot_longer(N:movie_facebook_likes,
               names_to = "variable",
               values_to = "value")

write_csv(imdb_radar,"./Dataset/shiny_radar.csv")


imdb_radar_raw <- group_without_standardize(imdb_radar_raw)
names(imdb_radar_raw) = c("genres","N", name_list_radar[3:length(name_list_radar)])
imdb_radar_raw <-
  imdb_radar_raw %>% 
  as_tibble() 

write_csv(imdb_radar_raw,"./Dataset/shiny_radar_df.csv")
```
- Wordcloud plot
  - Select genre and plot_keywords from cleaned datasets     
```{r, eval = F}
#Wordcloud

imdb_raw = 
  read_csv("imdb_explore_clean.csv") %>% 
  select(genres, plot_keyword) %>% 
  write.csv("./Dataset/shiny_keyword.csv")
```
- Valuebox plot
  - Use unqiue and genre filter to order the movie list     
```{r, eval = F}
# Data for valuebox:

df <- 
  read_csv("./Dataset/imdb_explore_clean.csv") %>% 
  select(movie_title, director_name, gross, title_year, genres) %>% 
  distinct(movie_title, genres, .keep_all = T)

genrelist <- unique(pull(df,genres))


df_final <-
  tibble(movie_title = "",
         director_name = "",
         gross = 0,
         title_year = 0,
         genres = "")


for (g in genrelist){
  
  df_sub <- 
    df %>% 
    filter(genres == g) %>% 
    slice(1:3)
  
  df_final <- rbind(df_final, df_sub)
    

  
}


df_final %>%
  slice(-1) %>% 
  write_csv("./Dataset/shiny_valuedf.csv")

```

## Data Exploratory


There are many variables in this dataset. And starting from our goal: try to predict the box office. We already have the dataset, thus first step is trying to find the association between the variables in this dataset.


### Association between Gross and Director's Facebook Likes

As we all know, director plays a very important role in a movie. But besides his professional skills in shooting movies, we can also explore whether the directors' social influence can be transformed into his movies' gross? That's also to say, whether some data about his or her social media associated with his or her movie. Facebook is one of the most popular social media in the world and in this dataset, it shows the directors' Facebook likes number. Here is the plot of Gross and Director's Facebook Likes:

```{r message=FALSE}
dataset = read.csv("./data/imdb_model_clean.csv") 
ep_dataset =read.csv("./data/imdb_explore_clean.csv")


# Find the association between director's facebook like and gross
directors = 
  dataset %>% 
  filter(director_facebook_likes != 0) %>% 
  mutate(log_director = log(director_facebook_likes)) %>% 
  filter(gross > 5000000 & log_director > 1 & log_director < 7 ) %>% 
  ggplot(aes(x = log_director, y = gross)) +
  geom_point()+
  geom_smooth(method='lm', se=TRUE) +
  labs( x = "Director's Facebook Likes",
        y = "Gross",
        title = "Director's Facebook Likes and Gross Explore") +
  theme(axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        plot.title = element_text(size = 14))
        
ggplotly(directors)
```

We preprocess the number of director's facebook likes with log function, and drop the missing values. Some extreme low gross are also excluded.From above plot we can see that there are some outliers, and most of mvoies' gross are concentrated. From the linear regression line, we can see their is a slight positive association between these two variables, thus, we can further explore its association in our model.


### Explore the Facebook Likes distributions among the casts

After take a look at director's Facebook likes, we want to further explore other casts' Facebook likes. As we mentioned before, Facebook is one of the most popular social media, and it's the biggest social platform all over the world. Until 2014, it has approximately 2.2 billion users, which accounts for one third of the global population. Thus, Facebook is one of the most important platform for director to promote their movies. In this dataset, it counts the Facebook likes of actor 1, 3 Facebook likes and cast total Facebook likes. Here is a violin plot of Facebook likes distribution:

```{r }
# explore the characteristics of some variables
cast = 
  ep_dataset %>% 
  select(actor_1_facebook_likes,actor_3_facebook_likes,cast_total_facebook_likes) %>% 
  filter(
    actor_1_facebook_likes != 0,
    cast_total_facebook_likes!= 0,
    actor_3_facebook_likes != 0
         ) %>% 
  distinct() %>% 
  mutate(
         Cast_total = cast_total_facebook_likes,
          Actor_1 = actor_1_facebook_likes,
         Actor_3 = actor_3_facebook_likes) %>% 
  select(Cast_total:Actor_3) %>% 
  pivot_longer(
    Actor_3:Cast_total,
    names_to = "facebook_likes",
    values_to = "number_likes"
  ) %>% 
  mutate(number_likes = log(number_likes)) %>% 
  ggplot(aes(x = reorder(facebook_likes, -number_likes) , y = number_likes, fill = facebook_likes)) + geom_violin() +
  geom_boxplot(width=0.1, color="black", alpha=0.2) +
  scale_fill_viridis(discrete = TRUE) +
  theme(
    legend.position="none",
    plot.title = element_text(size=11)
  ) +
  ggtitle("Staff's Facebook likes distibution")+
  xlab("Staff of Crew") +
  ylab("Facebook likes")  +
  theme(axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        plot.title = element_text(size = 14))

ggplotly(cast)
```

We also log the number of all Facebook likes and then plot it. In this plot, we can find that the range of cast total Facebook likes number is very similar to protagonist(`Actor 1`) 's Facebook likes number, from which we can conclude that minor part(`Actor 3`)'s Facebook likes contribute a little to the cast total Facebook likes.

This finding can provide a thought to directors when they thinking about casting and promotion. They can choose actors with great multimedia influence as protagonist if they wan to get much public's attention and have a good promotion effect. 

As for minor parts, they can pay more attention on actors' acting and less considering their influence in social media.


### Association between Cast Total Facebook Likes and Gross

After study the distribution of staff's Facebook Likes, we make a further step. Generally, we have a concept that with more attention on a movie, the movie will have more audience. This concept related with a connection between social media influence and public's action. Do people's attention will encourage them go to the movie theater and pay for the ticket? We are curious about it. Thus, here is a plot to give me a briefly answer. 

```{r message=FALSE}
totalfacebook = 
  dataset %>% 
  select(cast_total_facebook_likes, gross) %>% 
  mutate(log_cast_total_facebook_likes = log(cast_total_facebook_likes)) %>% 
  filter(log_cast_total_facebook_likes<9 & log_cast_total_facebook_likes>5) %>% 
  ggplot(aes(x = log_cast_total_facebook_likes, y = gross)) +
  geom_hex()+
  geom_smooth() +
  labs(
    x = "Cast Total Facebook Likes",
    y = "Gross",
    title = "Cast Total Facebook Likes and Gross Explore"
  ) +
  theme(axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        plot.title = element_text(size = 14))

ggplotly(totalfacebook)

```


### Association between IMBd Score and Gross


"Internet Movie Database (IMBd) is an online database of information related to films, television programs, home videos, video games, and streaming content online – including cast, production crew and personal biographies, plot summaries, trivia, ratings, and fan and critical reviews." from Wikipedia. In this dataset, it contains the IMBd score of each movies. This score is very important for us to understand the evaluation of movies in the market. And we want to explore whether there is a positive association between scores and gross. Here is the plot.

```{r message=FALSE}
imbdscoreplot = 
  dataset %>% 
  select(imdb_score, gross) %>% 
  filter(imdb_score>3.75 & imdb_score<8.5) %>% 
  ggplot(aes(x = imdb_score, y = gross)) +
  geom_point() +
  theme_bw(base_size=20) +
  geom_smooth(method='lm', se=TRUE) +
  labs(x="IMDb score of movie", y="Movie gross", title = "IMBd Score and Gross Explore") +
  theme(axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        plot.title = element_text(size = 14))

ggplotly(imbdscoreplot)

```

Similarly, we explore the movies within a general range of IMDB scores. Most movies' scores lie between 6 and 7. From the linear line, we can see a slight positive assiciation between these two variables. This is a good sign for us, and we made a further analysis in our model.



In this plot, we log the Cast Total Facebook likes. And we exclude some extreme point in Facebook Likes. There are some outliers around 8, and the association is not so obvious. Some high count of Facebook Likes still have low Gross. Thus, in the exploring stage, we can't get any conclusion about this association.


### Association between Budget and Genres

When we calculate the revenue of investigating a movie, budget can be an essential elements. But there are plenty of movie genres. We can explore the Budget and Movie Genre, from which we can further study the Budget and Gross. This plot help us to see is there a relationship between Movie Genres and Budget? 

```{r message=FALSE}
budget_genres = 
  ep_dataset %>% 
  select(budget, genres) %>% 
  distinct() %>% 
  filter(budget<3e+08) %>% 
  filter(genres != "News",
         genres !="Film-Noir") %>% 
  mutate(log_budget = log(budget)) %>% 
  ggplot( aes(x=reorder(genres,-budget, na.rm = TRUE), y=log_budget, fill=genres)) +
    geom_boxplot() +
    scale_fill_viridis(discrete = TRUE, alpha=0.6) +
    theme(
      legend.position="none",
      plot.title = element_text(size=11)
    ) +
    theme(axis.text.x = element_text(angle=90, hjust=1, vjust=1),
          axis.title.x = element_text(size = 14),
          axis.title.y = element_text(size = 14),
          plot.title = element_text(size = 14))+
    ggtitle("A boxplot with Budget") +
    xlab("Movie genre") +
    ylab("Budget of movie") 

ggplotly(budget_genres)
```

Although the median value of different movie genres' budget are different, but in general most genres' range are overlapping. It seems that there is no significant different in Movie Budget among different types of movies.


### Association between Budget and Gross


After studying the association between budget and genres, the next step is to explore the association between Budget and Gross. 
```{r message=FALSE }
ep_dataset %>% 
  select(budget, gross, genres) %>% 
  filter(budget<3e+08) %>% 
  ggplot(aes(x=budget, y=gross)) +
  geom_point( 
    color="black",
        fill="#69b3a2",
        shape=22,
        alpha=0.5,
        size=1,
        stroke = 1
        ) +
  geom_smooth()+
  labs(x = "Budget",
       y = "Gross",
       title = "Budget and Gross Explore") +
  theme(axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        plot.title = element_text(size = 14))
```

In this plot, we can see that most budget are less than 2e+08 dollar. And we can see an approximately positive association between Budget and Gross. It makes sense. More budget can make sure the quality of the movie in some extent, which will be more likely to achieve success in box office. Finally, high gross can reflect its success.


## Formal Analysis
### Overview

We aimed to investigating factors that associated with the gross and how these factors influenced the gross. We hoped to construct a robust model that may potentially guide film industry investors to make wise decisions after the pandemic. 

After correlation matrices, genres in general didn't have strong associations with the gross but disturbed the effect of other predictors (not shown). Thus, we decided to build single linear regression models with stratification of genres and presented in form of [interactive plot](https://gou29.shinyapps.io/p8015_final_shinyapp/).

Since the exploratory analyses and SLR models didn't provide much information, we decided to build the multiple linear regression model, from the full model, without a predetermined hypothesis. Meanwhile, in a situation of investing, genres are usually predetermined. Thus, we decided to build two models: model 1 contained predictors other than genres and model 2 contained genres only. 

We used a special stepwise regression method to find the best model. A general Stepwise regression is a "step by step" method to select predictors which have higher AIC scores. However, rather than comparing variables' AIC, our method based on the comparison of each model's accuracy and it will provide a better model than traditional AIC stepwise regression. Finally, we presented two final models in the end of the section and discussed some interesting discoveries based on our models.


```{r, warning=FALSE, include=FALSE, message=FALSE}
#function to plot heatmap
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}

 get_upper_tri <- function(cormat){
    cormat[lower.tri(cormat)]<- NA
    return(cormat)
  }
```


### Heatmap Plots of Correlation

#### Heatmap for Genres

```{r, warning=FALSE, echo = FALSE, message=FALSE}
#heatmap for genre
cor.mat.heat.genre <- round(cor(imdb_model_genre),2)
melted_cormat.genre <- melt(cor.mat.heat.genre)

cor.mat.heat.genre <- reorder_cormat(cor.mat.heat.genre)
upper_tri.heat.genre <- get_upper_tri(cor.mat.heat.genre)

# Melt the correlation matrix
melted_cormat_up_genre <- melt(upper_tri.heat.genre, na.rm = TRUE)

# Create a ggheatmap
ggheatmap_genre =
  ggplot(melted_cormat_up_genre, aes(Var2, Var1, fill = value))+
  geom_tile(color = "white")+
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
    midpoint = 0, limit = c(-1,1), space = "Lab", 
    name="Pearson\nCorrelation") +
  theme_minimal()+ # minimal theme
  theme(axis.text.x = element_text(angle = 90, 
    size = 10, hjust = 1, vjust = 0))+
  coord_fixed()+
  labs(
    title = "Figure 1. Heatmap of Gross and Genres",
    x = "",
    y = ""
  )

res_cor_up_genre = 
melted_cormat_up_genre %>%
  filter(
    Var1 == "gross"
  ) %>%
  pivot_wider(
    names_from = Var2,
    values_from = value
  ) %>%
  rename(
    " "=Var1
  ) %>%
  select(
    -gross
  )

ggheatmap_genre
```

```{r,echo = FALSE}
res_cor_up_genre
```

Figure 1 presented the correlation matrix between various genres and gross. From the heatmap, we can intuitively observe associations between genres and gross. Overall, we didn't observe any strong connections between genres and gross. Among all genres, adventure, fantasy, animation, family, action and science fiction have stronger associations with gross and they may contribute to the model later. 


#### Heatmap for non-Genre Factors 

```{r, warning=FALSE, echo=FALSE, message=FALSE}
#heatmap for no genre
cor.mat.heat.nogenre <- round(cor(imdb_model_no_genre,use = "complete.obs"),2)
melted_cormat.nogenre <- melt(cor.mat.heat.nogenre)

cor.mat.heat.nogenre <- reorder_cormat(cor.mat.heat.nogenre)
upper_tri.heat.nogenre <- get_upper_tri(cor.mat.heat.nogenre)

# Melt the correlation matrix
melted_cormat_up_nogenre <- melt(upper_tri.heat.nogenre, na.rm = TRUE)

# Create a ggheatmap
ggheatmap_nogenre =
  ggplot(melted_cormat_up_nogenre, aes(Var2, Var1, fill = value))+
  geom_tile(color = "white")+
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
    midpoint = 0, limit = c(-1,1), space = "Lab", 
    name="Pearson\nCorrelation") +
  theme_minimal()+ # minimal theme
  theme(axis.text.x = element_text(angle = 90, 
    size = 10, hjust = 1, vjust = 0))+
  coord_fixed()+
  labs(
    title = "Figure 2. Heatmap of Gross and non-Genre Factors",
    x = "",
    y = ""
  )

res_cor_up_nogenre = 
melted_cormat_up_nogenre %>%
  filter(
    Var1 == "gross"
  ) %>%
  pivot_wider(
    names_from = Var2,
    values_from = value
  ) %>%
  rename(
    " "=Var1
  ) %>%
  select(
    -gross
  )

ggheatmap_nogenre

```

```{r,echo = FALSE, , fig.cap= "Table 2. Correlations between Gross and non-Genre Factors"}
res_cor_up_nogenre
```

Figure 2 presented the correlation matrix between other factors and gross. We observed a better and stronger associations. Among all predictors, number of voted users, number of users for reviews, duration, IMDB scores, budget and number of genres have stronger associations with gross and they might contribute to the model later. 


### Stratified Single Linear Regression Model

From the heatmap, we observed a generally weak association between genres and gross. Therefore, we decided to perform single linear regression between gross and each predictor to discover possible significant predictors. Detailed plots and model summaries were located [HERE](https://gou29.shinyapps.io/p8015_final_shinyapp/). Interestingly, the majority of single linear regression models was significant. Thus, unfortunately, it didn't provide much information regarding the building of our final models and we decided build the model from the full model. 

### Model Building

We applied `regsubsets` from `leap` library to conduct the regression. Basically, this function constructs the null model first (contains only intercept) and combines various of variables to form an exhaustive subset of models. Within the subset, the function will compare the adjusted R2 and find the best combination of predictors. It is a better method than stepwise selection but needs a longer calculation time. Also, since cross validation has been done within the function, we don't need to perform the cross validation. Because we don't have many features, we decided to utilize this method to select the best model.

#### Model without Genres

```{r, warning=FALSE, include=FALSE, message=FALSE}
#model without genres 
lm.leaps_no_genre = 
  leaps::regsubsets(gross~., data = imdb_model_no_genre, nvmax = 8,
                     method = "seqrep")
sum.no_genre = summary(lm.leaps_no_genre)
```

```{r,echo = FALSE}
plot(sum.no_genre$adjr2,xlab='No. of Variables',ylab='Adj. R^2',type='l', main = "Figure 3. Plot of Number of Variables for non-Genre Model")
```
```{r,echo = FALSE}
plot(lm.leaps_no_genre,scale = "adjr2", main = "Figure 4. Plot of Important Variables for non-Genre Model")
```
  
  Figure 3 showed how many variables should the best model included. In our case, including 8 variables will make our model reach the highest accuracy (highest adjusted R2). 
  
  From Figure 4, we can conclude our model should include following variables: number of critics for reviews, Facebook likes of the director, Facebook likes of the primary actor/actress, number of voted users, total Facebook likes of the cast, number of users for reviews, IMDB score and the number of genres.
  
##### non-Genre Model

```{r, warning=FALSE, include=FALSE, message=FALSE}
#final model according to the selection
lm.no_genre = lm(gross ~ num_critic_for_reviews + director_facebook_likes + actor_1_facebook_likes + num_voted_users + cast_total_facebook_likes +  num_user_for_reviews + imdb_score + num_genres, data = na.omit(imdb_model_no_genre))
```

```{r,echo = FALSE, fig.cap= "Table 3. Estimates and P.values of the non-Genre Model"}
lm.no_genre %>%
  broom::tidy() %>%
  select(
    term, estimate, p.value
  ) %>%
  knitr::kable(digits = 3)
```



#### Model of Genres

```{r, warning=FALSE, include=FALSE, message=FALSE}
#stepwise with genres
lm.leaps_genre = leaps::regsubsets(gross~., data = imdb_model_genre, nvmax = 8,
                     method = "seqrep")
sum.genre = summary(lm.leaps_genre)
```

```{r,echo = FALSE}
plot(sum.genre$adjr2,xlab='No. of Variables',ylab='Adj. R^2',type='l',main = "Figure 5. Plot of Number of Variables for Genre Model")
plot(lm.leaps_genre,scale = "adjr2", main = "Figure 6. Plot of Important Varialbes for Genre Model")
```
  
Similarly, 8 variables should be included in our model according to Figure 5. From the Figure 6, we can conclude Action, Adventure, Fantasy, Sci-Fiction, Family, Drama, Horror and Documentary are important factors that influence the gross. However, since the accuracy (adjusted R2) is small, genre in general may not be an important factor to consider.

##### Genre Model

```{r, warning=FALSE, include=FALSE, message=FALSE}
lm.genre = 
  lm(gross ~ Action+ Adventure + Fantasy + Sci.Fi + Family + Drama + Horror + Documentary, data = na.omit(imdb_model_genre))
```

```{r,echo = FALSE}
lm.genre %>%
  broom::tidy() %>%
  select(
    term, estimate, p.value
  ) %>%
  knitr::kable(digits = 3)
```








### Diagnosis
```{r, echo= FALSE, , fig.cap= "Figure 7-10. Plots to Check the Assumptions after Transformation"}
par(mfrow=c(2,2))
plot(lm.no_genre)
```


Above provides assumption checking of the non-genre model. Since the non-Genre Model has a much higher accuracy, we check the assumption of it. Unfortunately, plots are not satisfactory. 

* A cluster of data locates mainly on the left and is not randomly distributed for the Residuals vs Fitted plot. However, other clear pattern is not observed, meaning that linear regression is still appropriate. 

* Normal QQ plot provides insight of its normality and the majority of our model lied on the line, which is acceptable. 

* For scale location plot, a cluster of data aggregates together showed the equal variance assumption was violated. 

* Lastly, we can observe some outliers that are influential from the Residuals vs Leverage plot.

Since nearly all the assumptions were violated in some extent, we decided to perform a box-cox transformation.

#### Box-Cox Transformation

Box-Cox transformation is another common method to normalize the data. Detailed information is provided [here](https://rss.onlinelibrary.wiley.com/doi/abs/10.1111/j.2517-6161.1964.tb00553.x). We performed Box-Cox transformation to our non-Genre model and check the assumptions again. 

```{r, echo= FALSE, fig.cap= "Figure 11. Fitted Lambda for Box-Cox Transformation."}
#find lambda for our model.
boxcox.lm = MASS::boxcox(lm.no_genre)
lambda <- boxcox.lm$x[which.max(boxcox.lm$y)]
```

Above provides the fitted lambda for the transformation and we transformed our model based on this lambda, which was `r round(lambda, digits = 3)`. 

#### Assumption Checking after Transformation

```{r, echo=FALSE , fig.cap= "Figure 12-15. Plots to Check the Assumptions after Transformation"}
lm.no_genre_lambda = lm(gross^lambda ~ num_critic_for_reviews + director_facebook_likes + actor_1_facebook_likes + num_voted_users + cast_total_facebook_likes +  num_user_for_reviews + imdb_score + num_genres, data = na.omit(imdb_model_no_genre))
par(mfrow=c(2,2))
plot(lm.no_genre_lambda)
```

Above presents the check of assumption after transformation. In general, Box-Cox transformation provided a quite satisfactory transformation to our model. 

* A cluster of data still exists on the left and is more randomly distributed compared the plot before transformation.However, a long "tail" on the right suggests a strong influence of outliers. 

* Transformed model lies on the line perfectly. 

* For scale location plot, a cluster of data aggregates together but the trend line is more horizontal than the previous scale location plot, showing that the homoskedasticity (equal spread of the data) is checked for the majority of the data. 

* Lastly, we can still observe some outliers that are influential from the Residuals vs Leverage plot.




### Limitation

Even though we performed Box-Cox transformation to make our non-genre model better satisfy the assumptions for regression, the model still didn't satisfy the assumptions well. It may implies a complicated model should be utilized, like machine learning algorithms. In addition to the method selection, the data should contain more features, like inflation rate, to provide more insights in model building.



## Findings & Conclusions

#### Regarding the Genre Model:

* Overall, genres really really don't matter, as long as the movie has a popular genre. There is a great overlap between the popular genres and the important genres in our genre model, but the accuracy is weak.

* From the genre model, action, adventure and family are the top three genres that can ignite the gross. We propose that the main audiences of movie theater are young people who are interested in visual effects or special effects. Surprisingly, family movie is another guarantee of the gross since family movies have a broader audiences. After all, watching movie together has became a family event for a long time. 

* Horror, documentary and drama have the negative effect on gross. We suppose the reason that genres with a limited scope of audiences will negatively affect on gross. These three genres usually keep audiences from entering the theater. (PS: I personally have never watched these three genres of movies in a movie theater.)

The Genre model may not be referential that much since nowadays, a film usually contains elements from multiple genres and it will be getting harder to define one film's genre in the future. Still, the model provides some insights. After all, horror movie indeed keep some audiences (like me) away from the theater. 


#### Regarding the non-Genre Model:

Overall, non-genre model can provide much more insights than the genre only model since it is more accurate. However, the coefficients are really surprising. 

* The most influential factor that positively influence the gross is the number of genres. In other words, the more genres (or more elements) are included in the movie, the more successful of the movie will be. It provides an interesting insight that the majority of audiences is much more interested in the film itself, rather than the stars or the production. Telling a good story is vitally important.    

* Other than the number of genres, factors that positively influence, with a great magnitude, the gross are number of critic for reviews and number of users for reviews. These two factors, to a large extend, represent the popularity of a movie and emphasizing the power of marketing. Marketing, in any industries, is nowadays an essential factor on determining the sales, especially with the fast growing of social media. However, since our data was collected from IMDB and either the number of critics and the number of users was cumulative, marketing of a successful movie should be a long term efforts. 

* Lastly, and ironically, IMDB scores negatively influence the gross dramatically. Why is? We believe that there exists an inconsistency between score and the gross, since none of the score related factors provides a strong and positive effect on gross. Such inconsistency may because only limited people actually score the movie.



